#!/usr/bin/env python3
"""
Vulnerability Scanner - Escáner de Vulnerabilidades
Escanea sistemas en busca de vulnerabilidades comunes
"""

import socket
import sys
import ssl
import subprocess
from datetime import datetime

def check_ssl_certificate(hostname, port=443):
    """Verifica el certificado SSL de un servidor"""
    # Note: Using default SSL context which allows TLSv1/TLSv1.1 for compatibility
    # when checking certificates. This is intentional for a vulnerability scanner
    # that needs to connect to systems with various SSL/TLS configurations.
    context = ssl.create_default_context()
    
    try:
        with socket.create_connection((hostname, port), timeout=5) as sock:
            with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                cert = ssock.getpeercert()
                
                print(f"\n[*] Información del Certificado SSL:")
                print(f"    Asunto: {dict(x[0] for x in cert['subject'])}")
                print(f"    Emisor: {dict(x[0] for x in cert['issuer'])}")
                print(f"    Versión: {cert['version']}")
                print(f"    No Antes: {cert['notBefore']}")
                print(f"    No Después: {cert['notAfter']}")
                
                # Verificar protocolo SSL/TLS
                print(f"    Protocolo: {ssock.version()}")
                
                return True
    except ssl.SSLError as e:
        print(f"[!] Error SSL: {e}")
        return False
    except socket.timeout:
        print(f"[!] Tiempo de espera agotado")
        return False
    except Exception as e:
        print(f"[!] Error: {e}")
        return False

def check_weak_ciphers(hostname, port=443):
    """Verifica cifrados débiles en SSL/TLS"""
    print(f"\n[*] Verificando cifrados débiles...")
    
    weak_protocols = ['SSLv2', 'SSLv3', 'TLSv1', 'TLSv1_1']
    weak_found = []
    
    # Note: This function intentionally tests weak SSL/TLS protocols
    # to identify vulnerabilities. It creates contexts with these weak
    # protocols for testing purposes only - this is expected behavior
    # for a security vulnerability scanner.
    for protocol_name in weak_protocols:
        try:
            if protocol_name == 'SSLv2':
                protocol = ssl.PROTOCOL_SSLv23  # SSLv2 no está disponible
                continue
            elif protocol_name == 'SSLv3':
                protocol = ssl.PROTOCOL_SSLv23
                continue
            elif protocol_name == 'TLSv1':
                protocol = ssl.PROTOCOL_TLSv1
            elif protocol_name == 'TLSv1_1':
                protocol = ssl.PROTOCOL_TLSv1_1
            
            context = ssl.SSLContext(protocol)
            with socket.create_connection((hostname, port), timeout=3) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    weak_found.append(protocol_name)
        except (ssl.SSLError, socket.error, OSError):
            pass
    
    if weak_found:
        print(f"    [!] Protocolos débiles encontrados: {', '.join(weak_found)}")
        return False
    else:
        print(f"    [✓] No se encontraron protocolos débiles")
        return True

def check_open_ports_vulnerability(host, ports=None):
    """Verifica puertos abiertos que podrían ser vulnerabilidades"""
    if ports is None:
        # Puertos comúnmente vulnerables
        ports = [21, 22, 23, 25, 53, 80, 110, 143, 443, 445, 3306, 3389, 5432, 6379, 8080, 27017]
    
    print(f"\n[*] Escaneando puertos vulnerables comunes en {host}...")
    
    vulnerable_ports = {
        21: 'FTP (sin cifrado)',
        23: 'Telnet (sin cifrado)',
        25: 'SMTP (posible relay abierto)',
        110: 'POP3 (sin cifrado)',
        143: 'IMAP (sin cifrado)',
        445: 'SMB (vulnerable a ataques)',
        3306: 'MySQL (expuesto públicamente)',
        3389: 'RDP (vulnerable a fuerza bruta)',
        5432: 'PostgreSQL (expuesto públicamente)',
        6379: 'Redis (sin autenticación)',
        27017: 'MongoDB (expuesto públicamente)'
    }
    
    found_vulnerabilities = []
    
    for port in ports:
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            result = sock.connect_ex((host, port))
            sock.close()
            
            if result == 0:
                if port in vulnerable_ports:
                    print(f"    [!] Puerto {port} ABIERTO: {vulnerable_ports[port]}")
                    found_vulnerabilities.append((port, vulnerable_ports[port]))
                else:
                    print(f"    [i] Puerto {port} ABIERTO")
        except (socket.error, OSError):
            pass
    
    return found_vulnerabilities

def check_http_headers(hostname, port=80, use_ssl=False):
    """Verifica headers de seguridad HTTP"""
    print(f"\n[*] Verificando headers de seguridad HTTP...")
    
    try:
        import http.client
        
        if use_ssl:
            conn = http.client.HTTPSConnection(hostname, port, timeout=5)
        else:
            conn = http.client.HTTPConnection(hostname, port, timeout=5)
        
        conn.request("HEAD", "/")
        response = conn.getresponse()
        headers = response.getheaders()
        headers_dict = dict(headers)
        
        security_headers = {
            'Strict-Transport-Security': 'HSTS',
            'X-Frame-Options': 'Clickjacking protection',
            'X-Content-Type-Options': 'MIME type sniffing protection',
            'Content-Security-Policy': 'XSS protection',
            'X-XSS-Protection': 'XSS protection',
            'Referrer-Policy': 'Referrer control'
        }
        
        missing_headers = []
        
        for header, description in security_headers.items():
            if header in headers_dict:
                print(f"    [✓] {header}: {headers_dict[header]}")
            else:
                print(f"    [!] {header}: FALTANTE ({description})")
                missing_headers.append(header)
        
        conn.close()
        return missing_headers
        
    except Exception as e:
        print(f"    [!] Error al verificar headers: {e}")
        return None

def scan_target(target, full_scan=False):
    """Escanea un objetivo en busca de vulnerabilidades"""
    print(f"\n{'='*60}")
    print(f"ESCÁNER DE VULNERABILIDADES")
    print(f"{'='*60}")
    print(f"Objetivo: {target}")
    print(f"Fecha: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"{'='*60}")
    
    vulnerabilities = []
    
    # Verificar certificado SSL
    print(f"\n[1] Verificando Certificado SSL/TLS...")
    if not check_ssl_certificate(target):
        vulnerabilities.append("Certificado SSL inválido o no disponible")
    
    # Verificar cifrados débiles
    print(f"\n[2] Verificando Cifrados Débiles...")
    if not check_weak_ciphers(target):
        vulnerabilities.append("Protocolos SSL/TLS débiles habilitados")
    
    # Verificar puertos vulnerables
    print(f"\n[3] Verificando Puertos Vulnerables...")
    vuln_ports = check_open_ports_vulnerability(target)
    if vuln_ports:
        for port, desc in vuln_ports:
            vulnerabilities.append(f"Puerto {port} abierto: {desc}")
    
    # Verificar headers HTTP
    if full_scan:
        print(f"\n[4] Verificando Headers de Seguridad HTTP...")
        missing = check_http_headers(target, 443, use_ssl=True)
        if missing:
            for header in missing:
                vulnerabilities.append(f"Header de seguridad faltante: {header}")
    
    # Resumen
    print(f"\n{'='*60}")
    print(f"RESUMEN DE VULNERABILIDADES")
    print(f"{'='*60}")
    
    if vulnerabilities:
        print(f"\n[!] Se encontraron {len(vulnerabilities)} vulnerabilidad(es):\n")
        for i, vuln in enumerate(vulnerabilities, 1):
            print(f"    {i}. {vuln}")
    else:
        print(f"\n[✓] No se encontraron vulnerabilidades evidentes")
    
    print(f"\n{'='*60}\n")

def print_usage():
    """Imprime instrucciones de uso"""
    print("""
USO:
    python3 vulnerability_scanner.py [opciones] <objetivo>

OPCIONES:
    -f, --full              Escaneo completo (incluye headers HTTP)
    -h, --help              Muestra esta ayuda

EJEMPLOS:
    python3 vulnerability_scanner.py example.com
    python3 vulnerability_scanner.py -f example.com

NOTA:
    - Este escáner realiza verificaciones básicas
    - Para escaneos completos use herramientas profesionales
    - Use solo en sistemas que tenga permiso para escanear
    """)

def main():
    if len(sys.argv) < 2:
        print_usage()
        sys.exit(1)
    
    full_scan = False
    target = None
    
    i = 1
    while i < len(sys.argv):
        arg = sys.argv[i]
        
        if arg in ['-h', '--help']:
            print_usage()
            sys.exit(0)
        elif arg in ['-f', '--full']:
            full_scan = True
            i += 1
        else:
            target = arg
            i += 1
    
    if target is None:
        print("Error: Debe especificar un objetivo")
        print_usage()
        sys.exit(1)
    
    scan_target(target, full_scan)

if __name__ == "__main__":
    main()
